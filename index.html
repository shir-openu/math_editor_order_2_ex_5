<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>×ª×¨×’×™×œ</title>

<!-- MathJax v3 -->
<script>
  window.MathJax = {
    tex: {
      inlineMath: [['\\(','\\)']],
      displayMath: [['\\[','\\]']],
      packages: {'[+]':['noerrors']}
    },
    loader: { load: ['[tex]/noerrors'] },
    chtml: { scale: 1.02, mtextInheritFont: true }
  };
</script>
<script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

<!-- mathjs -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.11.0/math.min.js"></script>

<style>
  :root{
    --bg:#0e1424; --panel:#111827; --ink:#e5e7eb; --muted:#9aa6b2;
    --ring:#334155; --accent:#60a5fa; --ok:#34d399; --bad:#ef4444;
    --field:#1f2a3a;
  }
  *{box-sizing:border-box}
  html,body{height:100%;direction:rtl}
  body{
    margin:0;background:var(--bg);color:var(--ink);
    font-family:'Segoe UI','Tahoma','Arial','David','FrankRuehl',serif;text-align:right;
  }
  .wrap{max-width:1200px;margin:0 auto;padding:22px}
  h1{font-size:1.35rem;margin:0 0 16px}

  /* Tabs */
  .tabs{display:flex; gap:6px; margin-bottom:12px; flex-wrap:wrap}
  .tab-btn{
    cursor:pointer; padding:8px 12px; border:1px solid var(--ring);
    background:var(--field); color:var(--ink); border-radius:10px; font-size:.95rem;
  }
  .tab-btn[aria-selected="true"]{border-color:var(--accent)}
  .tab-panel{display:none}
  .tab-panel.active{display:block}

  .grid{display:grid;grid-template-columns:1fr 1.2fr;gap:16px}
  @media (max-width:920px){.grid{grid-template-columns:1fr}}

  .card{background:var(--panel);border:1px solid var(--ring);border-radius:14px;padding:14px 16px}
  .section-title{font-size:1.05rem;margin:0 0 10px;color:var(--ink)}

  label{font-size:.92rem;color:var(--muted);display:block}
  textarea{
    width:100%;background:var(--field);color:var(--ink);
    border:1px solid var(--ring);border-radius:12px;
    padding:10px 12px;font-size:1rem;line-height:1.5;outline:none;
    direction:ltr;text-align:left;font-family:monospace;
  }
  textarea:focus{border-color:var(--accent)}

  .controls{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:8px;justify-content:flex-start}
  .pill{display:inline-flex;align-items:center;gap:8px;border:1px solid var(--ring);background:var(--field);padding:6px 10px;border-radius:999px;font-size:.9rem}
  .btn{cursor:pointer;background:var(--field);border:1px solid var(--ring);color:var(--ink);padding:8px 12px;border-radius:10px}
  .btn:hover{border-color:var(--accent)}

  .status{font-size:.9rem;margin-top:6px;text-align:right}
  .status.ok{color:var(--ok)} .status.bad{color:var(--bad)}

  .render{
    background:#0b1020;border:1px dashed #243047;border-radius:12px;
    padding:14px 16px;min-height:96px;overflow:auto;direction:ltr;text-align:center;
  }
  .hint{color:var(--muted);font-size:.95rem;margin-top:8px;line-height:1.9}
  .monospace{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Courier New",monospace}
  select{background:var(--field);color:var(--ink);border:1px solid var(--ring);border-radius:10px;padding:6px 8px}
</style>
<style>
  /* ADDITION: ×¡×’× ×•×Ÿ ××™× ×™××œ×™ ×œ×¡×¨×’×œ ×”××©×•×•××•×ª */
  .eqtb-wrap{ margin:8px 0 }
  .eqtb{
    display:flex; flex-wrap:wrap; gap:.4rem; align-items:center;
    background:#0b1020; border:1px solid #243047; border-radius:10px; padding:.5rem;
  }
  .eqtb button, .eqtb select{
    font:inherit; line-height:1; padding:.42rem .6rem;
    border:1px solid var(--ring); background:var(--field); color:var(--ink);
    border-radius:.5rem; cursor:pointer;
  }
  .eqtb button:hover{ border-color:var(--accent) }
  .eqtb .sep{ width:1px; height:1.4rem; background:#243047; margin:0 .2rem }
</style>

</head>
<body>
  <div class="wrap">
    <h1>×ª×¨×’×™×œ</h1>

    <!-- Tabs header -->
    <div class="tabs" role="tablist" aria-label="× ×™×•×•×˜ ×œ×©×•× ×™×•×ª">
      <button class="tab-btn" role="tab" aria-selected="true"  aria-controls="tab-ex"   id="tabbtn-ex">×ª×¨×’×™×œ</button>
      <button class="tab-btn" role="tab" aria-selected="false" aria-controls="tab-h1"  id="tabbtn-h1">×¨××– 1</button>
      <button class="tab-btn" role="tab" aria-selected="false" aria-controls="tab-h2"  id="tabbtn-h2">×¨××– 2</button>
      <button class="tab-btn" role="tab" aria-selected="false" aria-controls="tab-sol" id="tabbtn-sol">×”×¦×’×ª ×”×¤×ª×¨×•×Ÿ</button>
    </div>

    <!-- Panel: ×ª×¨×’×™×œ -->
    <section class="tab-panel active" id="tab-ex" role="tabpanel" aria-labelledby="tabbtn-ex">
      <div class="grid">
        <!-- ×™××™×Ÿ: ×”×©××œ×” -->
        <aside class="card">
          <div class="section-title">×¤×ª×¨×•</div>
          <div id="problemRender" class="render"></div>
        </aside>

        <!-- ×©×××œ: ×ª×©×•×‘×ª ×”×¡×˜×•×“× ×˜×™× -->
        <section class="card">
          <div class="section-title">×”×–×™× ×• ×›××Ÿ ××ª ×”×ª×©×•×‘×” ×”×¡×•×¤×™×ª</div>

<label for="inputRaw">×§×œ×˜ Plain ××• LaTeX</label>

<!-- ADDITION: mount ×œ×¢×•×¨×š ×”××©×•×•××•×ª ××¢×œ ×ª×™×‘×ª ×”×§×œ×˜ -->
<div id="eqToolbar" class="eqtb-wrap" aria-label="×¢×•×¨×š ××©×•×•××•×ª (×”×•×¡×¤×ª ×¡××œ×™×)"></div>

<textarea id="inputRaw" rows="6"
placeholder="×“×•×’××” ×œ×›×ª×™×‘×” ×‘LaTeX:
y = C_1 \sin(x) + C_2 \cos(x)
××• ×‘××¦×‘ Plain:
y = C_1*sin(x) + C_2*cos(x)"></textarea>

          
          <div class="controls">
            <span class="pill"><input type="checkbox" id="forceLatex"><label for="forceLatex" style="margin:0">××¦×‘ LaTeX</label></span>
            <button class="btn" id="btnClear">× ×™×§×•×™</button>
            <button class="btn" id="btnCheck">×‘×“×™×§×ª ×ª×©×•×‘×”</button>
            <span class="pill">××¦×‘ ×‘×“×™×§×”
              <select id="checkMode">
                <option value="general" selected>×¤×ª×¨×•×Ÿ ×›×œ×œ×™</option>
              </select>
            </span>
          </div>

          <div id="status" class="status"></div>

          <label style="margin-top:10px;display:block">×ª×¦×•×’×”</label>
          <div id="render" class="render"></div>

          <div id="checkMsg" class="status" style="margin-top:10px"></div>

          <div class="hint">
		    â€¢ ×‘×™×˜×•×™ ××•×¨×›×‘ ×™×© ×œ×©×™× ×‘×ª×•×š { }<br/>
            â€¢ ×‘×“×™×§×ª × ×›×•× ×•×ª ×¤×•×¢×œ×ª ×‘×§×œ×˜ Plain<br/>
			â€¢ ×”×˜×§×¡×˜ ×”×§×™×™× ×‘××¡×š ××™× ×• ×¤×ª×¨×•×Ÿ ×”×ª×¨×’×™×œ ××œ× ×“×•×’××” ×œ×›×ª×™×‘×ª ××©×•×•××” ×‘-LaTeX<br/>
            â€¢ ×™×© ×œ×”×©×ª××© ××š ×•×¨×§ ×‘×§×‘×•×¢×™× ××”×¦×•×¨×”: C_1, C_2, C_3 â€¦ ×¢×‘×•×¨ ×”×¤×ª×¨×•×Ÿ ×”×”×•××•×’× ×™<br/>
          </div>
        </section>
      </div>
    </section>

    <!-- Panel: ×¨××– 1 -->
    <section class="tab-panel" id="tab-h1" role="tabpanel" aria-labelledby="tabbtn-h1">
      <div class="card">
        <div class="section-title">×¨××– 1</div>
        <div class="hint" id="hint1Box"></div>
      </div>
    </section>

    <!-- Panel: ×¨××– 2 -->
    <section class="tab-panel" id="tab-h2" role="tabpanel" aria-labelledby="tabbtn-h2">
      <div class="card">
        <div class="section-title">×¨××– 2</div>
        <div class="hint" id="hint2Box"></div>
      </div>
    </section>

    <!-- Panel: ×”×¦×’×ª ×”×¤×ª×¨×•×Ÿ -->
    <section class="tab-panel" id="tab-sol" role="tabpanel" aria-labelledby="tabbtn-sol">
      <div class="card">
        <div class="section-title">×©×œ×“ ×”×¤×ª×¨×•×Ÿ</div>
        <!-- ×ª×©×•×‘×” ×¡×•×¤×™×ª ×’×“×•×œ×” ×•×‘×¨×•×¨×” -->
        <div class="render" id="solutionBox"></div>
        <!-- ×©×œ×‘×™× ×˜×§×¡×˜×•××œ×™×™× × ×¤×¨×“×™× -->
        <div class="hint" id="solutionSteps" style="margin-top:10px"></div>
      </div>
    </section>

  </div>

<script>
/* =========================
   ××‘× ×” × ×ª×•× ×™× ×©×œ ×ª×¨×’×™×œ×™×
   ========================= */
/* =========================
   ××¡×’×¨×ª ×’× ×¨×™×ª ×œ×¡×•×’×™ ×ª×¨×’×™×œ×™×
   ========================= */
const exerciseTypes = {
  undetermined_coefficients: {
    name: '××§×“××™× ×‘×œ×ª×™ ××•×’×“×¨×™×',
    requiredTerms: [
      { type: 'trig', function: 'cos', coefficient: 2, withConstant: true },
      { type: 'trig', function: 'sin', coefficient: 2, withConstant: true },
      { type: 'constant', value: 2, allowNegative: false }
    ],
    constantCount: 2
  }
};

const problems = [
  {
    id: 'ode_second_order_undetermined_coeff_01',
    type: 'undetermined_coefficients',
    title: '××¡×“×¨ ×©× ×™ â€” ××§×“××™× ×‘×œ×ª×™ ××•×’×“×¨×™×',
    latexProblem: String.raw`y'' + 4y = 8`,
    hint1Html: `
      ×–×•×”×™ ××©×•×•××” ×œ×™× ××¨×™×ª ××™-×”×•××•×’× ×™×ª ××¡×“×¨ ×©× ×™ ×¢× ××§×“××™× ×§×‘×•×¢×™×.<br/>
      ×”×©×ª××©×• ×‘×©×™×˜×ª ×”××§×“××™× ×œ×¤×ª×¨×•×Ÿ.<br/>
      ×”×¤×ª×¨×•×Ÿ ×”×›×œ×œ×™: \\(y = y_h + y_p\\)<br/>
      ×›××©×¨ \\(y_h\\) ×”×•× ×”×¤×ª×¨×•×Ÿ ×©×œ ×”××©×•×•××” ×”×”×•××•×’× ×™×ª \\(y'' + 4y = 0\\)
    `,
    hint2Html: `
      ×”××©×•×•××” ×”×”×•××•×’× ×™×ª: \\(y'' + 4y = 0\\) ×¢× ××©×•×•××” ××•×¤×™×™× ×™×ª \\(r^2 + 4 = 0\\)<br/>
      ×”×©×•×¨×©×™×: \\(r = \\pm 2i\\)<br/>
      ×”×¤×ª×¨×•×Ÿ ×”×”×•××•×’× ×™: \\(y_h = C_1 \\cos(2x) + C_2 \\sin(2x)\\)<br/>
      ×œ×¤×ª×¨×•×Ÿ ×”×¤×¨×˜×™: \\(g(x)\\) ×”×™× ×§×‘×•×¢ (×”××¡×¤×¨ 8), ×œ×›×Ÿ × × ×—×© \\(y_p = A\\) (×§×‘×•×¢).<br/>
      ×¢×œ×™×›× ×œ×’×–×•×¨ ××ª ×”×¤×ª×¨×•×Ÿ ×”×¤×¨×˜×™, ×œ×”×¦×™×‘×• ×‘××“"×¨ ×•×œ××¦×•× ××ª ×”×§×‘×•×¢ A ×‘×¢×–×¨×ª ×”×©×•×•××ª ×”××§×“××™× ×©×œ ×©× ×™ ×”××’×¤×™×.
    `,
    solutionDisplayLatex: String.raw`y = C_1 \cos(2x) + C_2 \sin(2x) + 2`,
    solutionStepsHtml: `
      ×”××©×•×•××” ×”×”×•××•×’× ×™×ª: \\(y'' + 4y = 0\\) ×¢× \\(r^2 + 4 = 0\\).<br/>
      ×©×•×¨×©×™× ××¨×•×›×‘×™×: \\(r = \\pm 2i\\).<br/>
      ×”×¤×ª×¨×•×Ÿ ×”×”×•××•×’× ×™: \\(y_h = C_1 \\cos(2x) + C_2 \\sin(2x)\\).<br/>
      ×œ×¤×ª×¨×•×Ÿ ×¤×¨×˜×™: × × ×—×© \\(y_p = A\\) (×§×‘×•×¢). ××– \\(y_p' = 0, y_p'' = 0\\).<br/>
      ×”×¦×‘×” ×‘××©×•×•××”: \\(0 + 4A = 8 \\Rightarrow A = 2\\).<br/>
      ×”×¤×ª×¨×•×Ÿ ×”×›×œ×œ×™: \\(y = C_1 \\cos(2x) + C_2 \\sin(2x) + 2\\).
    `,
    exampleInput: String.raw`y = C_1*e^x + C_2*x*e^x`
  }
];

/* =========================
   Tabs
   ========================= */
(function(){
  const buttons = [...document.querySelectorAll('.tab-btn')];
  const panels  = [...document.querySelectorAll('.tab-panel')];
  function activate(id){
    buttons.forEach(b=>b.setAttribute('aria-selected', String(b.getAttribute('aria-controls')===id)));
    panels.forEach(p=>p.classList.toggle('active', p.id===id));
    if (window.MathJax?.typesetPromise) MathJax.typesetPromise(panels.filter(p=>p.id===id));
  }
  buttons.forEach(btn=>btn.addEventListener('click', ()=>activate(btn.getAttribute('aria-controls'))));
})();

/* =========================
   Render helpers
   ========================= */
function waitForLibraries(cb){
  let tries=0;(function check(){
    if (typeof math!=='undefined' && window.MathJax) cb();
    else if(tries++<100) setTimeout(check,50);
    else console.error('Libraries failed to load');
  })();
}
async function renderLatexTo(containerId, latex, display=true){
  const el = document.getElementById(containerId);
  el.innerHTML = display ? `\\[ ${latex} \\]` : `\\(${latex}\\)`;
  if (window.MathJax?.typesetPromise){
    try{ await MathJax.typesetPromise([el]) }catch{ el.innerHTML = `<div class="monospace">${latex}</div>` }
  }
}
function setHtml(id, html){
  const el = document.getElementById(id);
  el.innerHTML = html;
  if (window.MathJax?.typesetPromise){ MathJax.typesetPromise([el]); }
}

/* =========================
   Normalization & parsing
   ========================= */
function sanitizeBasic(s){ return (s||'').replace(/[\u200E\u200F\u202A-\u202E\u2066-\u2069]/g,'').trim() }
function looksLikeLatex(s){ 
  return /\\[a-zA-Z]+|\\\[|\\\]|\\\(|\\\)|\$(?!\s*$)|\\int|\\sum|\\frac|\\sqrt|\\sin|\\cos|\\exp|\\cdot/.test(s) 
}
function insertImplicitMult(s){
  const id = '([A-Za-z](?:[A-Za-z0-9_]*))';
  
  // ×—×“×© â€” ××œ ×ª×™×’×¢ ×‘×§×¨×™××•×ª ×œ×¤×•× ×§×¦×™×•×ª ××•×›×¨×•×ª (exp, sin, cos, â€¦)
  s = s.replace(
    new RegExp(
      '\\b' + id + '\\s*(?=\\()(?!(?:\\s*\\)))' // ×–×”×•×ª + "("
    , 'g'),
    (m)=> {
      const name = m.replace(/\s*\($/,'').trim();
      const funcs = ['exp','sin','cos','tan','asin','acos','atan','log','ln','sqrt','abs'];
      return funcs.includes(name) ? m : m.replace(/\s*\($/,'*(');
    }
  );
  
  // ×”×•×¡×£ ××›×¤×œ×” ××©×ª××¢×ª ×‘×™×Ÿ ×§×‘×•×¢×™× (×›××• C1, C_1) ×œ×¤×•× ×§×¦×™×•×ª (×›××• sin, cos)
  s = s.replace(/\b([Cc]_?\d+)\s*([a-zA-Z]+\()/g, '$1*$2');
  
  s = s.replace(new RegExp(id + '\\s*(?=\\b[xX]\\b)', 'g'), '$1*');
  s = s.replace(new RegExp(id + '\\s*e\\s*\\^', 'g'), '$1*e^');
  s = s.replace(new RegExp(id + '\\s*(?=\\b(?:sin|cos|tan|asin|acos|atan|exp|log|ln|sqrt|abs)\\b)', 'g'), '$1*');
  return s;
}
function convertMathNotation(s){
  // Handle e^(...) patterns - more comprehensive
  s = s.replace(/\be\s*\^\s*\(/g, 'exp(');
  s = s.replace(/\be\s*\^\s*([a-zA-Z_]\w*)/g, 'exp($1)');
  s = s.replace(/\be\s*\^\s*([0-9]+)/g, 'exp($1)');
  s = s.replace(/\be\s*\^\s*\{([^}]+)\}/g, 'exp($1)');
  
  // Handle missing multiplication signs in exponential arguments
  // Convert exp(2x) to exp(2*x), exp(3x) to exp(3*x), etc.
  s = s.replace(/exp\((\d+)([a-zA-Z])\)/g, 'exp($1*$2)');
  
  // Handle other missing multiplications like 2x, 3x, etc.
  s = s.replace(/(\d+)([a-zA-Z])/g, '$1*$2');
  
  // Convert ^ to pow() function instead of ** for better mathjs compatibility
  s = s.replace(/([a-zA-Z_][a-zA-Z0-9_]*|\d+)\s*\^\s*([a-zA-Z0-9_]+|\([^)]+\))/g, 'pow($1, $2)');
  
  return s;
}
function normalizeToPlain(s){
  let t = sanitizeBasic(s);
  t = t.replace(/^\s*[yY]\s*(\(\s*x\s*\))?\s*=\s*/, '');
  
  // Convert LaTeX fractions to decimal/fraction format
  t = t.replace(/\\frac\{1\}\{2\}/g, '0.5');
  t = t.replace(/\\frac\{(\d+)\}\{(\d+)\}/g, '$1/$2');
  
  // Add multiplication after fractions when followed by variables/functions
  // Handle cases like "0.5e^x" -> "0.5*e^x"
  t = t.replace(/(0\.5|1\/2|\d+\/\d+)([a-zA-Z])/g, '$1*$2');
  
  // Convert LaTeX subscripts to underscore format
  // Convert C_{1}, C_{2} to C_1, C_2
  t = t.replace(/C_\{(\d+)\}/g, 'C_$1');
  
  // ADDITION TODAY: Add (x) to trigonometric and other functions if missing
  // Handle "sinx", "cosx" etc. (function directly followed by x)
  t = t.replace(/\b(sin|cos|tan|exp|ln|log|sqrt)x\b/g, '$1(x)');
  // Handle "sin x", "cos x" etc. (function followed by space and x)  
  t = t.replace(/\b(sin|cos|tan|exp|ln|log|sqrt)\s+x\b/g, '$1(x)');
  // Handle bare functions at end of string or before operators/spaces
  t = t.replace(/\b(sin|cos|tan|exp|ln|log|sqrt)(?=\s*[\+\-\*\/\s]|$)/g, '$1(x)');
  
  t = t.replace(/(\d),(\d)/g,'$1.$2');
  t = insertImplicitMult(t);
  t = convertMathNotation(t);
  return t;
}

/* =========================
   ×‘×•×“×§ ×’× ×¨×™ - ××•×ª×× ×œ×ª×¨×’×™×œ ×”××§×“××™× ×”×‘×œ×ª×™ ××•×’×“×¨×™×
   ========================= */
function checkSolution(userRaw, exerciseType) {
    if (!userRaw || !userRaw.trim() || !exerciseType) return false;
    
    try {
        console.log('STARTING CHECK - Exercise Type:', exerciseType.name);
        console.log('Raw input:', userRaw);
        
        // Normalize input
        const normalized = normalizeToPlain(userRaw).toLowerCase().replace(/\s+/g, '');
        console.log('Normalized input:', normalized);
        
        // Split into signed terms
        const terms = normalized.split(/([+\-])/).filter(t => t.trim() !== '');
        const signedTerms = [];
        let currentSign = '+';
        
        for (let i = 0; i < terms.length; i++) {
            const term = terms[i];
            if (term === '+' || term === '-') {
                currentSign = term;
            } else if (term.trim()) {
                signedTerms.push(currentSign + term);
                currentSign = '+';
            }
        }
        
        console.log('Signed terms:', signedTerms);
        
        // ×‘×“×™×§×” ×’× ×¨×™×ª ×©×œ ×¨×›×™×‘×™×
        const foundTerms = {};
        exerciseType.requiredTerms.forEach((reqTerm, index) => {
            foundTerms[reqTerm.type + '_' + (reqTerm.function || reqTerm.value || index)] = 0;
        });
        
        for (let term of signedTerms) {
            console.log('Analyzing term:', term);
            
            const isNegative = term.startsWith('-');
            const cleanTerm = term.replace(/^[+\-]/, '');
            let termMatched = false;
            
            // ×‘×“×™×§×ª ×¨×›×™×‘×™× ×œ×¤×™ ×”×’×“×¨×ª ×”×ª×¨×’×™×œ
            exerciseType.requiredTerms.forEach(reqTerm => {
                if (!termMatched) {
                    if (reqTerm.type === 'trig') {
                        const func = reqTerm.function;
                        const coeff = reqTerm.coefficient;
                        const key = reqTerm.type + '_' + reqTerm.function;
                        
                        // ×—×™×¤×•×© cos(2x) ××• sin(2x) ×¢× C_1 ××• C_2
                        const patterns = [
                            new RegExp(`^c(?:_?\\d*)\\*?${func}\\(${coeff}\\*?x\\)$`),
                            new RegExp(`^${func}\\(${coeff}\\*?x\\)\\*?c(?:_?\\d*)$`),
                            new RegExp(`^c(?:_?\\d*)\\*?${func}\\(${coeff}x\\)$`),
                            new RegExp(`^${func}\\(${coeff}x\\)\\*?c(?:_?\\d*)$`)
                        ];
                        
                        if (patterns.some(pattern => pattern.test(cleanTerm))) {
                            foundTerms[key]++;
                            termMatched = true;
                            console.log(`Found ${func}(${coeff}x) term:`, term);
                        }
                    } else if (reqTerm.type === 'constant') {
                        const expectedValue = reqTerm.value;
                        const key = reqTerm.type + '_' + reqTerm.value;
                        
                        // ×‘×“×™×§×ª ×§×‘×•×¢
                        if (new RegExp(`^${expectedValue}$`).test(cleanTerm)) {
                            if (isNegative && !reqTerm.allowNegative) {
                                console.log('REJECTION: Negative constant coefficient detected!');
                                return false;
                            }
                            
                            foundTerms[key]++;
                            termMatched = true;
                            console.log('Found constant term:', term);
                        }
                    }
                }
            });
            
            if (!termMatched) {
                console.log('REJECTION: Invalid or unrecognized term:', cleanTerm);
                return false;
            }
        }
        
        console.log('Found terms:', foundTerms);
        
        // ×‘×“×™×§×” ×©×›×œ ×”×¨×›×™×‘×™× ×”× ×“×¨×©×™× × ××¦××• ×‘×“×™×•×§ ×¤×¢× ××—×ª
        for (const [termKey, count] of Object.entries(foundTerms)) {
            if (count !== 1) {
                console.log(`REJECTION: Wrong number of ${termKey} terms: ${count}`);
                return false;
            }
        }
        
        // ×‘×“×™×§×ª ××¡×¤×¨ ×”×§×‘×•×¢×™×
        const constants = normalized.match(/c(?:_?\d+)/g) || [];
        if (constants.length < exerciseType.constantCount) {
            console.log(`REJECTION: Not enough constants - found ${constants.length}, expected ${exerciseType.constantCount}`);
            return false;
        }
        
        console.log('ALL CHECKS PASSED - SOLUTION ACCEPTED');
        return true;
        
    } catch (err) {
        console.error('Error in checker:', err);
        return false;
    }
}

/* =========================
   UI wiring + loadProblem
   ========================= */
waitForLibraries(function(){
  const inputEl = document.getElementById('inputRaw');
  const forceLatexEl = document.getElementById('forceLatex');
  const btnClear = document.getElementById('btnClear');
  const btnCheck = document.getElementById('btnCheck');

  function setStatus(msg, cls){
    const el = document.getElementById('status');
    el.className = `status ${cls||''}`;
    el.textContent = (msg||'') + (cls==='ok' ? '  @ open university' : '');
  }

  let debTimer=null; function debounce(fn,ms=180){ clearTimeout(debTimer); debTimer=setTimeout(fn,ms) }
  async function process(){
    const raw0 = inputEl.value, raw = sanitizeBasic(raw0);
    if(!raw){ document.getElementById('render').innerHTML=''; setStatus('',''); return }
    const forced = forceLatexEl.checked, latexMode = forced || looksLikeLatex(raw);
    try{
      if(latexMode){
        await renderLatexTo('render', raw, true);
        setStatus('××¢×•×‘×“ ×‘××¦×‘ LaTeX', 'ok');
      }else{
        console.log('Raw input:', raw);
        const plain = normalizeToPlain(raw);
        console.log('After normalization:', plain);
        const node = math.parse(plain);
        let latex = node.toTex({ parenthesis:'keep', implicit:'show' });
        
        // DEBUG: Let's see what mathjs actually returns for exp
        console.log('mathjs returned:', latex);
        
        // Fix the CORRECT pattern - mathjs returns C\_1 not C_1
        latex = latex.replace(/C\\_1/g, 'C_{1}');
        latex = latex.replace(/C\\_2/g, 'C_{2}');
        latex = latex.replace(/C\\_3/g, 'C_{3}');
        latex = latex.replace(/C\\_4/g, 'C_{4}');
        
        // Fix exp to e^x - mathjs returns \cdot\exp\left( x\right)
        latex = latex.replace(/\\cdot\\exp\\left\(\s*x\s*\\right\)/g, '\\cdot e^{x}');
        latex = latex.replace(/\\cdot\\exp\\left\(\s*([^)]+)\s*\\right\)/g, '\\cdot e^{$1}');
        latex = latex.replace(/\\exp\\left\(\s*x\s*\\right\)/g, 'e^{x}');
        latex = latex.replace(/\\exp\\left\(\s*([^)]+)\s*\\right\)/g, 'e^{$1}');
        latex = latex.replace(/exp\s*\(\s*x\s*\)/g, 'e^{x}');
        latex = latex.replace(/exp\s*\(\s*([^)]+)\s*\)/g, 'e^{$1}');
        
        // Remove unnecessary parentheses around simple variables in powers
        // \left( x\right)^{2} â†’ x^{2}  (for single variables)
        latex = latex.replace(/\\left\(\s*([a-zA-Z]+)\s*\\right\)\^/g, '$1^');
        // \left( x\right)^{power} â†’ x^{power}
        latex = latex.replace(/\\left\(\s*([a-zA-Z_][a-zA-Z0-9_]*)\s*\\right\)\^/g, '$1^');
        // Remove unnecessary parentheses around simple numbers in powers
        // \left(2\right)^{ x} â†’ 2^{ x}  (for single numbers)
        latex = latex.replace(/\\left\(\s*(\d+)\s*\\right\)\^/g, '$1^');
        
        console.log('After fixing:', latex);
        
        await renderLatexTo('render', latex, true);
        setStatus('××¢×•×‘×“ ×‘××¦×‘ Plain â†’ LaTeX ×‘×××¦×¢×•×ª mathjs', 'ok');
      }
    }catch(err){
      console.log('Parse error:', err);
      document.getElementById('render').innerHTML =
        `<div class="monospace">×©×’×™××” ×‘×¢×™×‘×•×“\n${(err?.message||String(err))}\n\n×§×œ×˜\n${raw}</div>`;
      setStatus('×©×’×™××” ×‘×¢×™×‘×•×“ â€” ×œ×‘×“×•×§ ×ª×—×‘×™×¨', 'bad');
    }
  }

  inputEl.addEventListener('input', ()=>debounce(process,120));
  forceLatexEl.addEventListener('change', process);
  document.getElementById('btnClear').addEventListener('click', ()=>{
    inputEl.value=''; document.getElementById('render').innerHTML=''; setStatus('','');
    document.getElementById('checkMsg').textContent=''; inputEl.focus();
  });
  document.getElementById('btnCheck').addEventListener('click', ()=>{
    const raw0 = inputEl.value, raw = sanitizeBasic(raw0);
    const latexMode = forceLatexEl.checked || looksLikeLatex(raw);
    const el = document.getElementById('checkMsg');
    
    // Get current problem and its exercise type
    const currentProblem = problems[0]; // Or get from current index
    const exerciseTypeDefinition = exerciseTypes[currentProblem.type];
    
    // Try to normalize LaTeX input for checking
    if(latexMode && !forceLatexEl.checked) {
      // Auto-detected LaTeX - try to normalize and check
      try {
        const normalized = normalizeToPlain(raw0);
        console.log('Auto-detected LaTeX, normalized to:', normalized);
        const ok = checkSolution(raw0, exerciseTypeDefinition);
        el.className='status ' + (ok?'ok':'bad'); 
        el.textContent = ok ? '×ª×©×•×‘×” × ×›×•× ×”' : '×ª×©×•×‘×” ×œ× × ×›×•× ×”';
      } catch(err) {
        el.className='status bad'; 
        el.textContent='×©×’×™××” ×‘× ×™×ª×•×— LaTeX - × ×¡×• ×‘××¦×‘ Plain ××• ×¡×× ×• "××¦×‘ LaTeX"';
      }
    } else if(latexMode && forceLatexEl.checked) {
      // Forced LaTeX mode - don't check
      el.className='status bad'; 
      el.textContent='×‘×“×™×§×ª × ×›×•× ×•×ª ×œ× ×¤×•×¢×œ×ª ×‘××¦×‘ LaTeX ××•×›×¨×— - ×‘×˜×œ×• ×”×¡×™××•×Ÿ ×œ×‘×“×™×§×”';
    } else {
      // Plain mode - normal check
      const ok = checkSolution(raw0, exerciseTypeDefinition);
      el.className='status ' + (ok?'ok':'bad'); 
      el.textContent = ok ? '×ª×©×•×‘×” × ×›×•× ×”' : '×ª×©×•×‘×” ×œ× × ×›×•× ×”';
    }
  });

  async function loadProblem(index=0){
    const p = problems[index];

    await renderLatexTo('problemRender', p.latexProblem, true);
    await renderLatexTo('solutionBox', p.solutionDisplayLatex, true);
    setHtml('solutionSteps', p.solutionStepsHtml);
    setHtml('hint1Box', p.hint1Html);
    setHtml('hint2Box', p.hint2Html);

    const inputEl2 = document.getElementById('inputRaw');
    inputEl2.value = p.exampleInput || '';
    (typeof process === 'function') && process();
  }

  loadProblem(0);
});
</script>

<script>
/* ADDITION: ××•×“×•×œ ×¢×•×¨×š ××©×•×•××•×ª â€” ×”×–×¨×§×ª ×˜×§×¡×˜ ×‘×œ×‘×“ ×œ×©×“×” #inputRaw */
(function(){
  function insertAtCaret(el, before, after){
    el.focus();
    const s = el.selectionStart ?? el.value.length;
    const e = el.selectionEnd   ?? el.value.length;
    const sel = el.value.slice(s, e);
    const text = before + (sel || '') + (after || '');
    el.value = el.value.slice(0, s) + text + el.value.slice(e);
    const pos = sel ? s + before.length + sel.length : s + before.length;
    el.setSelectionRange(pos, pos);
    // ××™×™×“×¢×™× ××ª ×”×§×•×“ ×”×§×™×™× ×©×œ×™ ×©×”×˜×§×¡×˜ ×”×©×ª× ×” â€” ×›×“×™ ×œ×©××¨ ××ª ×›×œ ×”×”×ª× ×”×’×•×ª
    el.dispatchEvent(new Event('input',  { bubbles:true }));
    el.dispatchEvent(new Event('change', { bubbles:true }));
  }

  function btn(label, title, onClick){
    const b = document.createElement('button');
    b.type = 'button'; b.textContent = label; if(title) b.title = title;
    b.addEventListener('click', onClick);
    return b;
  }

  // ×¤×•× ×§×¦×™×” ×¦×™×‘×•×¨×™×ª ×œ××ª×—×•×œ â€” ×œ× ×“×•×¨×›×ª ×¢×œ ×©××•×ª ×§×™×™××™×
  window.initEquationToolbar = function(opts){
    const input = document.querySelector(opts.target);
    const mount = document.querySelector(opts.mount);
    if(!input || !mount) return;

    const bar = document.createElement('div');
    bar.className = 'eqtb';

const items = [
  {label:'C_1', title:'×§×‘×•×¢ C_1',     click:()=>insertAtCaret(input,'C_1','')},
  {label:'C_2', title:'×§×‘×•×¢ C_2',     click:()=>insertAtCaret(input,'C_2','')},

  {label:'sin', title:'sin( )',       click:()=>insertAtCaret(input,'sin(',')')},
  {label:'cos', title:'cos( )',       click:()=>insertAtCaret(input,'cos(',')')},

  {label:'sin(ğ‘x)', title:'sin(ax)',  click:()=>insertAtCaret(input,'sin(ax)','')},
  {label:'cos(ğ‘x)', title:'cos(ax)',  click:()=>insertAtCaret(input,'cos(ax)','')},

  {label:'frac',title:'\\frac{ }{ }', click:()=>insertAtCaret(input,'\\frac{','}{}')},
  {label:'âˆš',   title:'\\sqrt{ }',    click:()=>insertAtCaret(input,'\\sqrt{','}')},

  {label:'e^x', title:'e^x',          click:()=>insertAtCaret(input,'e^x','')},
  {label:'e^{2x}', title:'e^(2x)',   click:()=>insertAtCaret(input,'e^(2*x)','')},
  {label:'x*e^x', title:'x*e^x',     click:()=>insertAtCaret(input,'x*e^x','')},

  {label:'x^2', title:'x^2',          click:()=>insertAtCaret(input,'x^2','')},
  {label:'x^3', title:'x^3',          click:()=>insertAtCaret(input,'x^3','')},

  {label:'+', title:'×—×™×‘×•×¨',          click:()=>insertAtCaret(input,' + ','')},
  {label:'âˆ«',   title:'\\int',        click:()=>insertAtCaret(input,'\\int ','')},
  
  {label:'( )', title:'×¡×•×’×¨×™×™× ×¢×’×•×œ×™×',   click:()=>insertAtCaret(input,'(',')')},
  {label:'{ }', title:'×¡×•×’×¨×™×™× ××¡×•×œ×¡×œ×™×', click:()=>insertAtCaret(input,'{','}')},

];

    items.forEach(it => bar.appendChild(btn(it.label, it.title, it.click)));
    mount.appendChild(bar);
  };
})();
</script>

<!-- ××ª×—×•×œ: ××¤×¢×™×œ ××ª ×”×¢×•×¨×š ×¢×œ #inputRaw ×•××ª×§×™×Ÿ ××•×ª×• ×‘-#eqToolbar -->
<script>
  initEquationToolbar({ target:'#inputRaw', mount:'#eqToolbar' });
</script>


</body>
</html>
